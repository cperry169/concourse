// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"

	db "github.com/concourse/concourse/atc/db"
)

type FakeContainerRepository struct {
	DestroyFailedContainersStub        func() (int, error)
	destroyFailedContainersMutex       sync.RWMutex
	destroyFailedContainersArgsForCall []struct {
	}
	destroyFailedContainersReturns struct {
		result1 int
		result2 error
	}
	destroyFailedContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	FindCreatedContainersStub        func(string) ([]string, error)
	findCreatedContainersMutex       sync.RWMutex
	findCreatedContainersArgsForCall []struct {
		arg1 string
	}
	findCreatedContainersReturns struct {
		result1 []string
		result2 error
	}
	findCreatedContainersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FindDestroyingContainersStub        func(string) ([]string, error)
	findDestroyingContainersMutex       sync.RWMutex
	findDestroyingContainersArgsForCall []struct {
		arg1 string
	}
	findDestroyingContainersReturns struct {
		result1 []string
		result2 error
	}
	findDestroyingContainersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FindFailedContainersStub        func(string) ([]string, error)
	findFailedContainersMutex       sync.RWMutex
	findFailedContainersArgsForCall []struct {
		arg1 string
	}
	findFailedContainersReturns struct {
		result1 []string
		result2 error
	}
	findFailedContainersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FindOrphanedContainersStub        func() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error)
	findOrphanedContainersMutex       sync.RWMutex
	findOrphanedContainersArgsForCall []struct {
	}
	findOrphanedContainersReturns struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	findOrphanedContainersReturnsOnCall map[int]struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	RemoveContainersStub        func([]string) error
	removeContainersMutex       sync.RWMutex
	removeContainersArgsForCall []struct {
		arg1 []string
	}
	removeContainersReturns struct {
		result1 error
	}
	removeContainersReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDestroyingContainersStub        func(string, []string) (int, error)
	removeDestroyingContainersMutex       sync.RWMutex
	removeDestroyingContainersArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	removeDestroyingContainersReturns struct {
		result1 int
		result2 error
	}
	removeDestroyingContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerRepository) DestroyFailedContainers() (int, error) {
	fake.destroyFailedContainersMutex.Lock()
	ret, specificReturn := fake.destroyFailedContainersReturnsOnCall[len(fake.destroyFailedContainersArgsForCall)]
	fake.destroyFailedContainersArgsForCall = append(fake.destroyFailedContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("DestroyFailedContainers", []interface{}{})
	fake.destroyFailedContainersMutex.Unlock()
	if fake.DestroyFailedContainersStub != nil {
		return fake.DestroyFailedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.destroyFailedContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) DestroyFailedContainersCallCount() int {
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	return len(fake.destroyFailedContainersArgsForCall)
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturns(result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	fake.destroyFailedContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	if fake.destroyFailedContainersReturnsOnCall == nil {
		fake.destroyFailedContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.destroyFailedContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindCreatedContainers(arg1 string) ([]string, error) {
	fake.findCreatedContainersMutex.Lock()
	ret, specificReturn := fake.findCreatedContainersReturnsOnCall[len(fake.findCreatedContainersArgsForCall)]
	fake.findCreatedContainersArgsForCall = append(fake.findCreatedContainersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindCreatedContainers", []interface{}{arg1})
	fake.findCreatedContainersMutex.Unlock()
	if fake.FindCreatedContainersStub != nil {
		return fake.FindCreatedContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findCreatedContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) FindCreatedContainersCallCount() int {
	fake.findCreatedContainersMutex.RLock()
	defer fake.findCreatedContainersMutex.RUnlock()
	return len(fake.findCreatedContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindCreatedContainersArgsForCall(i int) string {
	fake.findCreatedContainersMutex.RLock()
	defer fake.findCreatedContainersMutex.RUnlock()
	argsForCall := fake.findCreatedContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) FindCreatedContainersReturns(result1 []string, result2 error) {
	fake.FindCreatedContainersStub = nil
	fake.findCreatedContainersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindCreatedContainersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindCreatedContainersStub = nil
	if fake.findCreatedContainersReturnsOnCall == nil {
		fake.findCreatedContainersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findCreatedContainersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainers(arg1 string) ([]string, error) {
	fake.findDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.findDestroyingContainersReturnsOnCall[len(fake.findDestroyingContainersArgsForCall)]
	fake.findDestroyingContainersArgsForCall = append(fake.findDestroyingContainersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindDestroyingContainers", []interface{}{arg1})
	fake.findDestroyingContainersMutex.Unlock()
	if fake.FindDestroyingContainersStub != nil {
		return fake.FindDestroyingContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findDestroyingContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) FindDestroyingContainersCallCount() int {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	return len(fake.findDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindDestroyingContainersArgsForCall(i int) string {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	argsForCall := fake.findDestroyingContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturns(result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	fake.findDestroyingContainersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	if fake.findDestroyingContainersReturnsOnCall == nil {
		fake.findDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findDestroyingContainersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindFailedContainers(arg1 string) ([]string, error) {
	fake.findFailedContainersMutex.Lock()
	ret, specificReturn := fake.findFailedContainersReturnsOnCall[len(fake.findFailedContainersArgsForCall)]
	fake.findFailedContainersArgsForCall = append(fake.findFailedContainersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindFailedContainers", []interface{}{arg1})
	fake.findFailedContainersMutex.Unlock()
	if fake.FindFailedContainersStub != nil {
		return fake.FindFailedContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findFailedContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) FindFailedContainersCallCount() int {
	fake.findFailedContainersMutex.RLock()
	defer fake.findFailedContainersMutex.RUnlock()
	return len(fake.findFailedContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindFailedContainersArgsForCall(i int) string {
	fake.findFailedContainersMutex.RLock()
	defer fake.findFailedContainersMutex.RUnlock()
	argsForCall := fake.findFailedContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) FindFailedContainersReturns(result1 []string, result2 error) {
	fake.FindFailedContainersStub = nil
	fake.findFailedContainersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindFailedContainersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindFailedContainersStub = nil
	if fake.findFailedContainersReturnsOnCall == nil {
		fake.findFailedContainersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findFailedContainersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindOrphanedContainers() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error) {
	fake.findOrphanedContainersMutex.Lock()
	ret, specificReturn := fake.findOrphanedContainersReturnsOnCall[len(fake.findOrphanedContainersArgsForCall)]
	fake.findOrphanedContainersArgsForCall = append(fake.findOrphanedContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("FindOrphanedContainers", []interface{}{})
	fake.findOrphanedContainersMutex.Unlock()
	if fake.FindOrphanedContainersStub != nil {
		return fake.FindOrphanedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.findOrphanedContainersReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeContainerRepository) FindOrphanedContainersCallCount() int {
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	return len(fake.findOrphanedContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturns(result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	fake.findOrphanedContainersReturns = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturnsOnCall(i int, result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	if fake.findOrphanedContainersReturnsOnCall == nil {
		fake.findOrphanedContainersReturnsOnCall = make(map[int]struct {
			result1 []db.CreatingContainer
			result2 []db.CreatedContainer
			result3 []db.DestroyingContainer
			result4 error
		})
	}
	fake.findOrphanedContainersReturnsOnCall[i] = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) RemoveContainers(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.removeContainersMutex.Lock()
	ret, specificReturn := fake.removeContainersReturnsOnCall[len(fake.removeContainersArgsForCall)]
	fake.removeContainersArgsForCall = append(fake.removeContainersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("RemoveContainers", []interface{}{arg1Copy})
	fake.removeContainersMutex.Unlock()
	if fake.RemoveContainersStub != nil {
		return fake.RemoveContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeContainersReturns
	return fakeReturns.result1
}

func (fake *FakeContainerRepository) RemoveContainersCallCount() int {
	fake.removeContainersMutex.RLock()
	defer fake.removeContainersMutex.RUnlock()
	return len(fake.removeContainersArgsForCall)
}

func (fake *FakeContainerRepository) RemoveContainersArgsForCall(i int) []string {
	fake.removeContainersMutex.RLock()
	defer fake.removeContainersMutex.RUnlock()
	argsForCall := fake.removeContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) RemoveContainersReturns(result1 error) {
	fake.RemoveContainersStub = nil
	fake.removeContainersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerRepository) RemoveContainersReturnsOnCall(i int, result1 error) {
	fake.RemoveContainersStub = nil
	if fake.removeContainersReturnsOnCall == nil {
		fake.removeContainersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeContainersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainers(arg1 string, arg2 []string) (int, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removeDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.removeDestroyingContainersReturnsOnCall[len(fake.removeDestroyingContainersArgsForCall)]
	fake.removeDestroyingContainersArgsForCall = append(fake.removeDestroyingContainersArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("RemoveDestroyingContainers", []interface{}{arg1, arg2Copy})
	fake.removeDestroyingContainersMutex.Unlock()
	if fake.RemoveDestroyingContainersStub != nil {
		return fake.RemoveDestroyingContainersStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeDestroyingContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersCallCount() int {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	return len(fake.removeDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersArgsForCall(i int) (string, []string) {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	argsForCall := fake.removeDestroyingContainersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturns(result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	fake.removeDestroyingContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	if fake.removeDestroyingContainersReturnsOnCall == nil {
		fake.removeDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeDestroyingContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	fake.findCreatedContainersMutex.RLock()
	defer fake.findCreatedContainersMutex.RUnlock()
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	fake.findFailedContainersMutex.RLock()
	defer fake.findFailedContainersMutex.RUnlock()
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	fake.removeContainersMutex.RLock()
	defer fake.removeContainersMutex.RUnlock()
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ContainerRepository = new(FakeContainerRepository)
